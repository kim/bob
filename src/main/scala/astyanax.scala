// sketchy implementation of a cassandra client using the async interface
// generated by thrift.
//
// re: the silly name: Astyanax was the son of Hector, brother of Cassandra
object Astyanax {

    import java.util.concurrent.{ ArrayBlockingQueue
                                , BlockingQueue
                                , Callable
                                , Executors
                                , ExecutorService
                                , Future
                                }
    import java.nio.ByteBuffer

    import scala.concurrent.SyncVar
    import scala.collection.JavaConversions._

    import org.apache.cassandra.thrift._
    import org.apache.thrift.protocol._
    import org.apache.thrift.async._
    import org.apache.thrift.transport._


    // we need to thread the TTransport to be able to close the connection
    type Client = (Cassandra.AsyncClient, TTransport)

    // basically an Either monad, encapsulates the response (`A`), or any errors
    case class Result[A](value: Either[Throwable, A]) {
        def map[B](f: A => B): Result[B] =
            flatMap(x => Right(f(x)))

        def flatMap[B](f: A => Result[B]): Result[B] =
            value match {
                case Left(x)  => Left(x)
                case Right(x) => f(x)
            }
    }

    implicit
    def eitherToResult[A](e: Either[Throwable, A]): Result[A] = Result(e)

    implicit
    def resultToEither[A](r: Result[A]): Either[Throwable, A] = r.value

    // a monad of cassandra API calls. can be used to sequence calls, necessary
    // if those need to use the same connection (such as `setKeyspace` followed
    // by `get`). the computation stops on the first error.
    trait Task[A] {
        def apply(c: Client): Promise[A]

        def map[B](f: A => B): Task[B] =
            flatMap(x => task(c => promise(Result(Right(f(x))) -> c)))

        def flatMap[B](f: A => Task[B]): Task[B] =
            task(c => apply(c).flatMap(a => f(a).apply(c)))
    }

    def task[A](f: Client => Promise[A]): Task[A] =
        new Task[A] { def apply(c: Client) = f(c) }

    // since we're wrapping the async API, when running a `Task`, we'll get back
    // a promise, which will eventually yield the result. note that is threads
    // the `Client` as well, so `Promises` can be sequenced in the `Task` monad
    trait Promise[A] {
        def get: (Result[A], Client)

        def map[B](f: A => B): Promise[B] =
            promise(get match { case (a,c) => a.map(f) -> c })

        def flatMap[B](f: A => Promise[B]): Promise[B] =
            get match { case (a,c) => promise(a.flatMap(x => f(x).get._1) -> c) }
    }

    def promise[A](f: (Client, SyncVar[Result[A]]) => Unit)
                  (c: Client)
    : Promise[A] = {
        val res = new SyncVar[Result[A]]
        f(c, res)
        promise(res.take -> c)
    }

    def promise[A](g: => (Result[A], Client)): Promise[A] =
        new Promise[A] { def get = g }


    // API ====================================================================
    type SetKeyspace = Cassandra.AsyncClient.set_keyspace_call
    type Get = Cassandra.AsyncClient.get_call

    def setKeyspace(name: String): Task[Unit] =
        task(promise(_._1.set_keyspace(name, _)))

    def get(key: String, cf: String, col: String, cl: ConsistencyLevel)
    : Task[ColumnOrSuperColumn] =
        task(promise(
            _._1.get( ByteBuffer.wrap(key.getBytes)
                    , new ColumnPath(cf).setColumn(col.getBytes)
                    , cl
                    , _
                    )
        ))
    // ========================================================================

    case class CassandraConfig()
    case class CassandraRunner
        ( cs: BlockingQueue[Client]
        , e:  ExecutorService
        )
    {
        def submit[A](t: Task[A]): Future[Result[A]] =
            e.submit(t(cs.take).get match { case (a, c) => cs.add(c); a })
    }

    // TODO: `runCassandra` should actually run a cassandra monad (which threads
    // state such as the `ExecutorService` and the client queue), rather than
    // being a simplistic combinator
    def runCassandra(conf: CassandraConfig, hosts: (String, Int)*)
                    (f: CassandraRunner => Unit)
    {
        val mgr = new TAsyncClientManager
        val pool = new ArrayBlockingQueue[Client](hosts.size)
        hosts.foreach { case (h, p) =>
            pool.add({
                val sock = new TNonblockingSocket(h, p)
                (new Cassandra.AsyncClient(factory, mgr, sock), sock)
            })
        }
        val exec = Executors.newCachedThreadPool

        f(CassandraRunner(pool, exec))

        exec.shutdownNow()
        pool.foreach { case (_, sock) => sock.close() }
        mgr.stop()
    }

    // TODO: likewise, `runT` should run in the cassandra monad
    def runT[A](t: Task[A])(implicit R: CassandraRunner): Future[Result[A]] =
        R.submit(t)

    private
    val factory = new TProtocolFactory {
        def getProtocol(transport: TTransport): TProtocol =
              new TBinaryProtocol(transport)
    }

    implicit
    def callback[A, B](p: SyncVar[Result[B]]): AsyncMethodCallback[A] =
        new AsyncMethodCallback[A] {
            def onComplete(r: A) {
              try { r match {
                  // damn you, thift authors: `getResult` is part of the
                  // interface of `TAsyncMethodCall`, but not declared in the
                  // base class, so generated methods (which exist even for
                  // `void` results) don't inherit
                  case x: Get =>
                      p put Right(x.getResult.asInstanceOf[B])
                  case x: SetKeyspace =>
                      p put Right(x.getResult.asInstanceOf[B])
                  case x => sys.error("wtf?")
              }}
              catch { case e => p put Left(e) }
            }
            def onError(e: Exception) { p put Left(e) }
        }

    implicit
    def fnToCallable[A](f: => A): Callable[A] = new Callable[A] { def call = f }
}

// EXAMPLE
object Main extends App {
    import scala.concurrent.SyncVar
    import scala.util.control.Exception._

    import Astyanax._
    import org.apache.cassandra.thrift._

    runCassandra(CassandraConfig(), ("localhost", 9160)) { c =>
        val r = for {
          _ <- setKeyspace("Counters")
          y <- get("yyy", "ByHour_p_o_t", "bar", ConsistencyLevel.ONE)
          z <- get("zzz", "ByHour_p_o_t", "bar", ConsistencyLevel.ONE)
        } yield y :: z :: Nil

        println(runT(r)(c).get) // prints 'Result(Left(NotFoundException()))'
    }
}

// vim: set ts=4 sw=4 et:
